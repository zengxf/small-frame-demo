# 模型创建：

# 自己写模型
# 1. 拆分封装，看懂结构图

# 2. 调pytorch写好的模型(推荐)
  
# 3. github的作用
#  github 网络名称 

# 4. 用yolo的分类来训练(推荐)


# 自定义数据集，自定义模型，自定义训练过程 face_age.py
# 1.了解有没有开源数据集
# 人脸相关的
#  https://blog.csdn.net/zhw864680355/article/details/102969876

# 2.分析一下数据集的分类数量
#    2.1 了解标签的格式
#        预想的类别与真实的类别是否一样。做一个集合的差集

#    2.2 业务需要的划分
#        数据标签的重组

#    2.3 重组之后类别标签的数量分析 
#        数据平衡（删除、添加、类别合并）


# 3. 要么自己写一个自定义dataset，要么拆分训练集和验证集
#    一定要避免数据泄露（最佳方法，先离线划分好训练集、验证集、测试集 torch.ImageFolder）。
#    测试/验证集，训练术

# 4. 始终在上一轮best.pt基础上继续训练，或者做为初始权重
#    model.load_state_dict(checkpoint['model_state_dict'])
#    当前的学习率 = 上一次的学习率 
#    for .... in epochs
#             if epoch == 1, acc = 85
#             if epoch == 2, acc = 86, 保存best.pt
#             if epoch == 3, acc = 84
#             if epoch == 4, acc = 87, 保存best.pt

#  5. 可以设置不同类别之间的损失占比平衡系数
#     5.1 最开始的训练不要设
#        class_weights = torch.tensor([0.5, 1.0, 1.0, 1.0, 1.0, 1.5, 1.0, 1.0, 1.9, 1.0, 1.5]).float()
#        criterion = nn.CrossEntropyLoss(weight=class_weights.to(device))
#
#     5.2 根据训练结果调整，如果效果不佳类别，调大一些

#  6. 关注整体准确率，以及子类别的准确率，如果能补齐短板，整个准确率就会增加

 


